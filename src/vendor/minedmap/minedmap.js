// MinedMap Viewer JavaScript (commit 643035eaed96dfa5e99badba8dff02ab557bd207)
// Copyright Matthias Schiffer
// Licensed under MIT License
//
// shortened by Christopher Besch

// bsearch-based array element check
function contains(array, elem) {
    let min = 0, max = array.length;

    while (min < max) {
        const i = min + Math.floor((max - min) / 2);
        const cur = array[i];

        if (cur === elem)
            return true;
        else if (cur < elem)
            min = i + 1;
        else
            max = i;
    }

    return false;
}

const MinedMapLayer = L.TileLayer.extend({
    initialize: function(mipmaps, layer) {
        L.TileLayer.prototype.initialize.call(this, '', {
            detectRetina: true,
            tileSize: 512,
            zoomReverse: true,
            minZoom: -(mipmaps.length - 1),
            maxZoom: 0,
            attribution: 'Generated by <a href="https://github.com/neocturne/MinedMap">MinedMap</a>',
        });

        this.options.maxNativeZoom = this.options.maxZoom;
        this.options.maxZoom = undefined;

        this.mipmaps = mipmaps;
        this.layer = layer;
    },

    createTile: function(coords, done) {
        const tile = L.TileLayer.prototype.createTile.call(this, coords, done);

        if (coords.z - this.options.zoomOffset >= 0)
            L.DomUtil.addClass(tile, 'overzoomed');

        return tile;
    },

    getTileUrl: function(coords) {
        let z = -coords.z + this.options.zoomOffset;
        if (z < 0)
            z = 0;

        const mipmap = this.mipmaps[z];

        if (coords.x < mipmap.bounds.minX || coords.x > mipmap.bounds.maxX ||
            coords.y < mipmap.bounds.minZ || coords.y > mipmap.bounds.maxZ ||
            !contains(mipmap.regions[coords.y] || [], coords.x))
            return L.Util.emptyImageUrl;


        return 'data/' + this.layer + '/' + z + '/r.' + coords.x + '.' + coords.y + '.png';
    },
});

// this function is a shortened version of the original from the MinedMap Viewer
createMap = async function() {
    const { mipmaps, spawn } = await fetch('./data/info.json', { cache: 'no-store' }).then((resp) => {
        if (!resp.ok) {
            throw new Error(`fetch info.json failed: ${resp.status}`);
        }
        return resp.json();
    });

    const map = L.map('map', {
        center: [-spawn.z, spawn.x],
        zoom: 0,
        minZoom: -(mipmaps.length - 1),
        maxZoom: 5,
        // we're not on a sphere
        crs: L.CRS.Simple,
        maxBounds: [
            [-512 * (mipmaps[0].bounds.maxZ + 1), 512 * mipmaps[0].bounds.minX],
            [-512 * mipmaps[0].bounds.minZ, 512 * (mipmaps[0].bounds.maxX + 1)],
        ],
    });
    const mapLayer = new MinedMapLayer(mipmaps, 'map');
    mapLayer.addTo(map);
    const lightLayer = new MinedMapLayer(mipmaps, 'light');
    L.control.layers({}, { 'Illumination': lightLayer }).addTo(map);

    return map;
}
