// MinedMap Viewer JavaScript (commit 643035eaed96dfa5e99badba8dff02ab557bd207)
// MIT License

// Copyright (c) 2015 Matthias Schiffer

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// shortened by Christopher Besch

// bsearch-based array element check
function contains(array, elem) {
    let min = 0, max = array.length;

    while (min < max) {
        const i = min + Math.floor((max - min) / 2);
        const cur = array[i];

        if (cur === elem)
            return true;
        else if (cur < elem)
            min = i + 1;
        else
            max = i;
    }

    return false;
}

const MinedMapLayer = L.TileLayer.extend({
    initialize: function(mipmaps, layer, cache_buster) {
        L.TileLayer.prototype.initialize.call(this, '', {
            detectRetina: true,
            tileSize: 512,
            zoomReverse: true,
            minZoom: -(mipmaps.length - 1),
            maxZoom: 0,
            attribution: 'Generated by <a href="https://github.com/neocturne/MinedMap">MinedMap</a>',
        });

        this.options.maxNativeZoom = this.options.maxZoom;
        this.options.maxZoom = undefined;

        this.mipmaps = mipmaps;
        this.layer = layer;

        this.cache_buster = cache_buster;
    },

    createTile: function(coords, done) {
        const tile = L.TileLayer.prototype.createTile.call(this, coords, done);

        if (coords.z - this.options.zoomOffset >= 0)
            L.DomUtil.addClass(tile, 'overzoomed');

        return tile;
    },

    getTileUrl: function(coords) {
        let z = -coords.z + this.options.zoomOffset;
        if (z < 0)
            z = 0;

        const mipmap = this.mipmaps[z];

        if (coords.x < mipmap.bounds.minX || coords.x > mipmap.bounds.maxX ||
            coords.y < mipmap.bounds.minZ || coords.y > mipmap.bounds.maxZ ||
            !contains(mipmap.regions[coords.y] || [], coords.x))
            return L.Util.emptyImageUrl;


        return 'data/' + this.layer + '/' + z + '/r.' + coords.x + '.' + coords.y + '.png?cache_buster=' + this.cache_buster;
    },
});

// This function is a shortened version of the original from the MinedMap Viewer.
// It also contains the cache_buster feature that didn't exist upstream.
createMap = async function(cache_buster) {
    const { mipmaps, spawn } = await fetch('./data/info.json', { cache: 'no-store' }).then((resp) => {
        if (!resp.ok) {
            throw new Error(`fetch info.json failed: ${resp.status}`);
        }
        return resp.json();
    });

    const map = L.map('map', {
        center: [-spawn.z, spawn.x],
        zoom: 0,
        minZoom: -(mipmaps.length - 1),
        maxZoom: 5,
        // we're not on a sphere
        crs: L.CRS.Simple,
        maxBounds: [
            [-512 * (mipmaps[0].bounds.maxZ + 1), 512 * mipmaps[0].bounds.minX],
            [-512 * mipmaps[0].bounds.minZ, 512 * (mipmaps[0].bounds.maxX + 1)],
        ],
    });
    const mapLayer = new MinedMapLayer(mipmaps, 'map', cache_buster);
    mapLayer.addTo(map);
    const lightLayer = new MinedMapLayer(mipmaps, 'light', cache_buster);

    return [map, lightLayer];
}
